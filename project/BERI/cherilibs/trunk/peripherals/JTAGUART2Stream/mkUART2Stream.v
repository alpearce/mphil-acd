//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Mon Jul  2 14:26:38 BST 2012
//
// Method conflict info:
// Method: asi_stream_in
// Conflict-free: asi_stream_in_ready,
// 	       aso_stream_out_data,
// 	       aso_stream_out_valid,
// 	       aso_stream_out,
// 	       avm_m0,
// 	       avm_m0_writedata,
// 	       avm_m0_address,
// 	       avm_m0_read,
// 	       avm_m0_write
// Conflicts: asi_stream_in
//
// Method: asi_stream_in_ready
// Conflict-free: asi_stream_in,
// 	       asi_stream_in_ready,
// 	       aso_stream_out_data,
// 	       aso_stream_out_valid,
// 	       aso_stream_out,
// 	       avm_m0_read,
// 	       avm_m0_write
// Sequenced after (restricted): avm_m0, avm_m0_writedata, avm_m0_address
//
// Method: aso_stream_out_data
// Conflict-free: asi_stream_in,
// 	       asi_stream_in_ready,
// 	       aso_stream_out_data,
// 	       aso_stream_out_valid,
// 	       avm_m0,
// 	       avm_m0_writedata,
// 	       avm_m0_address,
// 	       avm_m0_read,
// 	       avm_m0_write
// Sequenced after (restricted): aso_stream_out
//
// Method: aso_stream_out_valid
// Conflict-free: asi_stream_in,
// 	       asi_stream_in_ready,
// 	       aso_stream_out_data,
// 	       aso_stream_out_valid,
// 	       avm_m0,
// 	       avm_m0_writedata,
// 	       avm_m0_address,
// 	       avm_m0_read,
// 	       avm_m0_write
// Sequenced after (restricted): aso_stream_out
//
// Method: aso_stream_out
// Conflict-free: asi_stream_in,
// 	       asi_stream_in_ready,
// 	       avm_m0,
// 	       avm_m0_writedata,
// 	       avm_m0_address,
// 	       avm_m0_read,
// 	       avm_m0_write
// Sequenced before (restricted): aso_stream_out_data, aso_stream_out_valid
// Conflicts: aso_stream_out
//
// Method: avm_m0
// Conflict-free: asi_stream_in,
// 	       aso_stream_out_data,
// 	       aso_stream_out_valid,
// 	       aso_stream_out,
// 	       avm_m0_writedata,
// 	       avm_m0_address,
// 	       avm_m0_read,
// 	       avm_m0_write
// Sequenced before (restricted): asi_stream_in_ready
// Conflicts: avm_m0
//
// Method: avm_m0_writedata
// Conflict-free: asi_stream_in,
// 	       aso_stream_out_data,
// 	       aso_stream_out_valid,
// 	       aso_stream_out,
// 	       avm_m0,
// 	       avm_m0_writedata,
// 	       avm_m0_address,
// 	       avm_m0_read,
// 	       avm_m0_write
// Sequenced before (restricted): asi_stream_in_ready
//
// Method: avm_m0_address
// Conflict-free: asi_stream_in,
// 	       aso_stream_out_data,
// 	       aso_stream_out_valid,
// 	       aso_stream_out,
// 	       avm_m0,
// 	       avm_m0_writedata,
// 	       avm_m0_address,
// 	       avm_m0_read,
// 	       avm_m0_write
// Sequenced before (restricted): asi_stream_in_ready
//
// Method: avm_m0_read
// Conflict-free: asi_stream_in,
// 	       asi_stream_in_ready,
// 	       aso_stream_out_data,
// 	       aso_stream_out_valid,
// 	       aso_stream_out,
// 	       avm_m0,
// 	       avm_m0_writedata,
// 	       avm_m0_address,
// 	       avm_m0_read,
// 	       avm_m0_write
//
// Method: avm_m0_write
// Conflict-free: asi_stream_in,
// 	       asi_stream_in_ready,
// 	       aso_stream_out_data,
// 	       aso_stream_out_valid,
// 	       aso_stream_out,
// 	       avm_m0,
// 	       avm_m0_writedata,
// 	       avm_m0_address,
// 	       avm_m0_read,
// 	       avm_m0_write
//
//
// Ports:
// Name                         I/O  size props
// asi_stream_in_ready            O     1
// aso_stream_out_data            O     8
// aso_stream_out_valid           O     1
// avm_m0_writedata               O    32 reg
// avm_m0_address                 O     3
// avm_m0_read                    O     1 reg
// avm_m0_write                   O     1 reg
// csi_clockreset_clk             I     1 clock
// csi_clockreset_reset_n         I     1 reset
// asi_stream_in_data             I     8
// asi_stream_in_valid            I     1
// aso_stream_out_ready           I     1
// avm_m0_readdata                I    32
// avm_m0_waitrequest             I     1
//
// Combinational paths from inputs to outputs:
//   aso_stream_out_ready -> aso_stream_out_data
//   aso_stream_out_ready -> aso_stream_out_valid
//   avm_m0_waitrequest -> asi_stream_in_ready
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkUART2Stream(csi_clockreset_clk,
		     csi_clockreset_reset_n,

		     asi_stream_in_data,
		     asi_stream_in_valid,

		     asi_stream_in_ready,

		     aso_stream_out_data,

		     aso_stream_out_valid,

		     aso_stream_out_ready,

		     avm_m0_readdata,
		     avm_m0_waitrequest,

		     avm_m0_writedata,

		     avm_m0_address,

		     avm_m0_read,

		     avm_m0_write);
  input  csi_clockreset_clk;
  input  csi_clockreset_reset_n;

  // action method asi_stream_in
  input  [7 : 0] asi_stream_in_data;
  input  asi_stream_in_valid;

  // value method asi_stream_in_ready
  output asi_stream_in_ready;

  // value method aso_stream_out_data
  output [7 : 0] aso_stream_out_data;

  // value method aso_stream_out_valid
  output aso_stream_out_valid;

  // action method aso_stream_out
  input  aso_stream_out_ready;

  // action method avm_m0
  input  [31 : 0] avm_m0_readdata;
  input  avm_m0_waitrequest;

  // value method avm_m0_writedata
  output [31 : 0] avm_m0_writedata;

  // value method avm_m0_address
  output [2 : 0] avm_m0_address;

  // value method avm_m0_read
  output avm_m0_read;

  // value method avm_m0_write
  output avm_m0_write;

  // signals for module outputs
  wire [31 : 0] avm_m0_writedata;
  wire [7 : 0] aso_stream_out_data;
  wire [2 : 0] avm_m0_address;
  wire asi_stream_in_ready, aso_stream_out_valid, avm_m0_read, avm_m0_write;

  // inlined wires
  reg [36 : 0] merge_merge_sink_rw$wget;
  wire [8 : 0] asi_adapter_d_dw$wget, aso_adapter_data_dw$wget;
  wire [2 : 0] merge_merge_arbiter_grant_vector$wget;
  wire avm_adapter_full_master_datareturnbuf_r_enq$whas,
       avm_adapter_full_master_signal_read$whas,
       avm_adapter_full_master_signal_write$whas,
       merge_merge_sink_rw$whas;

  // register avm_adapter_full_master_address_r
  reg avm_adapter_full_master_address_r;
  wire avm_adapter_full_master_address_r$D_IN,
       avm_adapter_full_master_address_r$EN;

  // register avm_adapter_full_master_byteenable_r
  reg [3 : 0] avm_adapter_full_master_byteenable_r;
  wire [3 : 0] avm_adapter_full_master_byteenable_r$D_IN;
  wire avm_adapter_full_master_byteenable_r$EN;

  // register avm_adapter_full_master_datareturnbuf_countReg
  reg [2 : 0] avm_adapter_full_master_datareturnbuf_countReg;
  wire [2 : 0] avm_adapter_full_master_datareturnbuf_countReg$D_IN;
  wire avm_adapter_full_master_datareturnbuf_countReg$EN;

  // register avm_adapter_full_master_read_r
  reg avm_adapter_full_master_read_r;
  wire avm_adapter_full_master_read_r$D_IN, avm_adapter_full_master_read_r$EN;

  // register avm_adapter_full_master_write_r
  reg avm_adapter_full_master_write_r;
  wire avm_adapter_full_master_write_r$D_IN,
       avm_adapter_full_master_write_r$EN;

  // register avm_adapter_full_master_writedata_r
  reg [31 : 0] avm_adapter_full_master_writedata_r;
  wire [31 : 0] avm_adapter_full_master_writedata_r$D_IN;
  wire avm_adapter_full_master_writedata_r$EN;

  // register merge_merge_arbiter_lock_arbiter
  reg merge_merge_arbiter_lock_arbiter;
  wire merge_merge_arbiter_lock_arbiter$D_IN,
       merge_merge_arbiter_lock_arbiter$EN;

  // register merge_merge_arbiter_priority_vector
  reg [2 : 0] merge_merge_arbiter_priority_vector;
  wire [2 : 0] merge_merge_arbiter_priority_vector$D_IN;
  wire merge_merge_arbiter_priority_vector$EN;

  // register write_space
  reg [15 : 0] write_space;
  wire [15 : 0] write_space$D_IN;
  wire write_space$EN;

  // ports of submodule asi_adapter_f
  wire [7 : 0] asi_adapter_f$D_IN, asi_adapter_f$D_OUT;
  wire asi_adapter_f$CLR,
       asi_adapter_f$DEQ,
       asi_adapter_f$EMPTY_N,
       asi_adapter_f$ENQ,
       asi_adapter_f$FULL_N;

  // ports of submodule aso_buf
  wire [7 : 0] aso_buf$D_IN, aso_buf$D_OUT;
  wire aso_buf$CLR, aso_buf$DEQ, aso_buf$EMPTY_N, aso_buf$ENQ, aso_buf$FULL_N;

  // ports of submodule avm_adapter_full_master_datareturnbuf
  wire [32 : 0] avm_adapter_full_master_datareturnbuf$D_IN,
		avm_adapter_full_master_datareturnbuf$D_OUT;
  wire avm_adapter_full_master_datareturnbuf$CLR,
       avm_adapter_full_master_datareturnbuf$DEQ,
       avm_adapter_full_master_datareturnbuf$EMPTY_N,
       avm_adapter_full_master_datareturnbuf$ENQ;

  // ports of submodule avm_adapter_full_master_pending_acks
  wire [1 : 0] avm_adapter_full_master_pending_acks$D_IN,
	       avm_adapter_full_master_pending_acks$D_OUT;
  wire avm_adapter_full_master_pending_acks$CLR,
       avm_adapter_full_master_pending_acks$DEQ,
       avm_adapter_full_master_pending_acks$EMPTY_N,
       avm_adapter_full_master_pending_acks$ENQ,
       avm_adapter_full_master_pending_acks$FULL_N;

  // ports of submodule merge_merge_dataport
  wire [34 : 0] merge_merge_dataport$D_IN, merge_merge_dataport$D_OUT;
  wire merge_merge_dataport$CLR,
       merge_merge_dataport$DEQ,
       merge_merge_dataport$EMPTY_N,
       merge_merge_dataport$ENQ,
       merge_merge_dataport$FULL_N;

  // ports of submodule merge_merge_dataport_1
  wire [34 : 0] merge_merge_dataport_1$D_IN, merge_merge_dataport_1$D_OUT;
  wire merge_merge_dataport_1$CLR,
       merge_merge_dataport_1$DEQ,
       merge_merge_dataport_1$EMPTY_N,
       merge_merge_dataport_1$ENQ,
       merge_merge_dataport_1$FULL_N;

  // ports of submodule merge_merge_dataport_2
  wire [34 : 0] merge_merge_dataport_2$D_IN, merge_merge_dataport_2$D_OUT;
  wire merge_merge_dataport_2$CLR,
       merge_merge_dataport_2$DEQ,
       merge_merge_dataport_2$EMPTY_N,
       merge_merge_dataport_2$ENQ,
       merge_merge_dataport_2$FULL_N;

  // ports of submodule merge_responses_vector
  wire [32 : 0] merge_responses_vector$D_IN, merge_responses_vector$D_OUT;
  wire merge_responses_vector$CLR,
       merge_responses_vector$DEQ,
       merge_responses_vector$EMPTY_N,
       merge_responses_vector$ENQ,
       merge_responses_vector$FULL_N;

  // ports of submodule merge_responses_vector_1
  wire [32 : 0] merge_responses_vector_1$D_IN;
  wire merge_responses_vector_1$CLR,
       merge_responses_vector_1$DEQ,
       merge_responses_vector_1$EMPTY_N,
       merge_responses_vector_1$ENQ,
       merge_responses_vector_1$FULL_N;

  // ports of submodule merge_responses_vector_2
  wire [32 : 0] merge_responses_vector_2$D_IN, merge_responses_vector_2$D_OUT;
  wire merge_responses_vector_2$CLR,
       merge_responses_vector_2$DEQ,
       merge_responses_vector_2$EMPTY_N,
       merge_responses_vector_2$ENQ,
       merge_responses_vector_2$FULL_N;

  // ports of submodule merge_tags
  wire [1 : 0] merge_tags$D_IN, merge_tags$D_OUT;
  wire merge_tags$CLR,
       merge_tags$DEQ,
       merge_tags$EMPTY_N,
       merge_tags$ENQ,
       merge_tags$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_ClientServerRequest,
       CAN_FIRE_RL_ClientServerResponse,
       CAN_FIRE_RL_asi_adapter_push_data_into_fifo,
       CAN_FIRE_RL_ask_space_available,
       CAN_FIRE_RL_avm_adapter_full_master_buffer_data_read,
       CAN_FIRE_RL_avm_adapter_full_master_datareturnbuf__updateLevelCounter,
       CAN_FIRE_RL_avm_adapter_full_master_do_read_reg,
       CAN_FIRE_RL_avm_adapter_full_master_do_write_reg,
       CAN_FIRE_RL_avm_adapter_full_master_signal_data_write,
       CAN_FIRE_RL_avm_adapter_full_master_signal_mem_null,
       CAN_FIRE_RL_do_not_need_streat_to_jtag_response,
       CAN_FIRE_RL_merge_merge_arbiter_every,
       CAN_FIRE_RL_merge_merge_grant_one,
       CAN_FIRE_RL_merge_merge_grant_one_1,
       CAN_FIRE_RL_merge_merge_grant_one_2,
       CAN_FIRE_RL_merge_merge_send_requests,
       CAN_FIRE_RL_merge_merge_send_requests_1,
       CAN_FIRE_RL_merge_merge_send_requests_2,
       CAN_FIRE_RL_mkConnectionGetPut,
       CAN_FIRE_RL_receive_read_data,
       CAN_FIRE_RL_receive_space_available,
       CAN_FIRE_RL_request_any_data,
       CAN_FIRE_RL_stream_to_jtag,
       CAN_FIRE_asi_stream_in,
       CAN_FIRE_aso_stream_out,
       CAN_FIRE_avm_m0,
       WILL_FIRE_RL_ClientServerRequest,
       WILL_FIRE_RL_ClientServerResponse,
       WILL_FIRE_RL_asi_adapter_push_data_into_fifo,
       WILL_FIRE_RL_ask_space_available,
       WILL_FIRE_RL_avm_adapter_full_master_buffer_data_read,
       WILL_FIRE_RL_avm_adapter_full_master_datareturnbuf__updateLevelCounter,
       WILL_FIRE_RL_avm_adapter_full_master_do_read_reg,
       WILL_FIRE_RL_avm_adapter_full_master_do_write_reg,
       WILL_FIRE_RL_avm_adapter_full_master_signal_data_write,
       WILL_FIRE_RL_avm_adapter_full_master_signal_mem_null,
       WILL_FIRE_RL_do_not_need_streat_to_jtag_response,
       WILL_FIRE_RL_merge_merge_arbiter_every,
       WILL_FIRE_RL_merge_merge_grant_one,
       WILL_FIRE_RL_merge_merge_grant_one_1,
       WILL_FIRE_RL_merge_merge_grant_one_2,
       WILL_FIRE_RL_merge_merge_send_requests,
       WILL_FIRE_RL_merge_merge_send_requests_1,
       WILL_FIRE_RL_merge_merge_send_requests_2,
       WILL_FIRE_RL_mkConnectionGetPut,
       WILL_FIRE_RL_receive_read_data,
       WILL_FIRE_RL_receive_space_available,
       WILL_FIRE_RL_request_any_data,
       WILL_FIRE_RL_stream_to_jtag,
       WILL_FIRE_asi_stream_in,
       WILL_FIRE_aso_stream_out,
       WILL_FIRE_avm_m0;

  // inputs to muxes for submodule ports
  wire [36 : 0] MUX_merge_merge_sink_rw$wset_1__VAL_1,
		MUX_merge_merge_sink_rw$wset_1__VAL_2,
		MUX_merge_merge_sink_rw$wset_1__VAL_3;
  wire [32 : 0] MUX_avm_adapter_full_master_datareturnbuf$enq_1__VAL_1;

  // remaining internal signals
  reg CASE_merge_tagsD_OUT_NOT_merge_tagsD_OUT_EQ__ETC__q1;
  wire [31 : 0] IF_merge_responses_vectorD_OUT_BIT_32_THEN_me_ETC__q2,
		IF_merge_responses_vector_2_first__00_BIT_32_0_ETC___d282;
  wire [1 : 0] IF_IF_merge_merge_arbiter_lock_arbiter_6_THEN__ETC___d246,
	       IF_IF_merge_merge_arbiter_lock_arbiter_6_THEN__ETC___d248,
	       x_grant_id__h3947;
  wire IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d229,
       IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d230,
       IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d231,
       IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d240,
       IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d88,
       NOT_avm_adapter_full_master_avalonwait_wget__4_ETC___d132,
       NOT_merge_merge_arbiter_priority_vector_7_BIT__ETC___d63,
       NOT_merge_merge_arbiter_priority_vector_7_BIT__ETC___d84,
       NOT_merge_merge_arbiter_priority_vector_7_BIT__ETC___d96;

  // action method asi_stream_in
  assign CAN_FIRE_asi_stream_in = 1'd1 ;
  assign WILL_FIRE_asi_stream_in = 1'd1 ;

  // value method asi_stream_in_ready
  assign asi_stream_in_ready = asi_adapter_f$FULL_N ;

  // value method aso_stream_out_data
  assign aso_stream_out_data = aso_adapter_data_dw$wget[7:0] ;

  // value method aso_stream_out_valid
  assign aso_stream_out_valid =
	     CAN_FIRE_RL_mkConnectionGetPut && aso_adapter_data_dw$wget[8] ;

  // action method aso_stream_out
  assign CAN_FIRE_aso_stream_out = 1'd1 ;
  assign WILL_FIRE_aso_stream_out = 1'd1 ;

  // action method avm_m0
  assign CAN_FIRE_avm_m0 = 1'd1 ;
  assign WILL_FIRE_avm_m0 = 1'd1 ;

  // value method avm_m0_writedata
  assign avm_m0_writedata = avm_adapter_full_master_writedata_r ;

  // value method avm_m0_address
  assign avm_m0_address = { avm_adapter_full_master_address_r, 2'b0 } ;

  // value method avm_m0_read
  assign avm_m0_read = avm_adapter_full_master_read_r ;

  // value method avm_m0_write
  assign avm_m0_write = avm_adapter_full_master_write_r ;

  // submodule asi_adapter_f
  FIFOL1 #(.width(32'd8)) asi_adapter_f(.RST_N(csi_clockreset_reset_n),
					.CLK(csi_clockreset_clk),
					.D_IN(asi_adapter_f$D_IN),
					.ENQ(asi_adapter_f$ENQ),
					.DEQ(asi_adapter_f$DEQ),
					.CLR(asi_adapter_f$CLR),
					.D_OUT(asi_adapter_f$D_OUT),
					.FULL_N(asi_adapter_f$FULL_N),
					.EMPTY_N(asi_adapter_f$EMPTY_N));

  // submodule aso_buf
  FIFO2 #(.width(32'd8),
	  .guarded(32'd1)) aso_buf(.RST_N(csi_clockreset_reset_n),
				   .CLK(csi_clockreset_clk),
				   .D_IN(aso_buf$D_IN),
				   .ENQ(aso_buf$ENQ),
				   .DEQ(aso_buf$DEQ),
				   .CLR(aso_buf$CLR),
				   .D_OUT(aso_buf$D_OUT),
				   .FULL_N(aso_buf$FULL_N),
				   .EMPTY_N(aso_buf$EMPTY_N));

  // submodule avm_adapter_full_master_datareturnbuf
  SizedFIFO #(.p1width(32'd33),
	      .p2depth(32'd4),
	      .p3cntr_width(32'd2),
	      .guarded(32'd1)) avm_adapter_full_master_datareturnbuf(.RST_N(csi_clockreset_reset_n),
								     .CLK(csi_clockreset_clk),
								     .D_IN(avm_adapter_full_master_datareturnbuf$D_IN),
								     .ENQ(avm_adapter_full_master_datareturnbuf$ENQ),
								     .DEQ(avm_adapter_full_master_datareturnbuf$DEQ),
								     .CLR(avm_adapter_full_master_datareturnbuf$CLR),
								     .D_OUT(avm_adapter_full_master_datareturnbuf$D_OUT),
								     .FULL_N(),
								     .EMPTY_N(avm_adapter_full_master_datareturnbuf$EMPTY_N));

  // submodule avm_adapter_full_master_pending_acks
  FIFO2 #(.width(32'd2),
	  .guarded(32'd1)) avm_adapter_full_master_pending_acks(.RST_N(csi_clockreset_reset_n),
								.CLK(csi_clockreset_clk),
								.D_IN(avm_adapter_full_master_pending_acks$D_IN),
								.ENQ(avm_adapter_full_master_pending_acks$ENQ),
								.DEQ(avm_adapter_full_master_pending_acks$DEQ),
								.CLR(avm_adapter_full_master_pending_acks$CLR),
								.D_OUT(avm_adapter_full_master_pending_acks$D_OUT),
								.FULL_N(avm_adapter_full_master_pending_acks$FULL_N),
								.EMPTY_N(avm_adapter_full_master_pending_acks$EMPTY_N));

  // submodule merge_merge_dataport
  FIFOL1 #(.width(32'd35)) merge_merge_dataport(.RST_N(csi_clockreset_reset_n),
						.CLK(csi_clockreset_clk),
						.D_IN(merge_merge_dataport$D_IN),
						.ENQ(merge_merge_dataport$ENQ),
						.DEQ(merge_merge_dataport$DEQ),
						.CLR(merge_merge_dataport$CLR),
						.D_OUT(merge_merge_dataport$D_OUT),
						.FULL_N(merge_merge_dataport$FULL_N),
						.EMPTY_N(merge_merge_dataport$EMPTY_N));

  // submodule merge_merge_dataport_1
  FIFOL1 #(.width(32'd35)) merge_merge_dataport_1(.RST_N(csi_clockreset_reset_n),
						  .CLK(csi_clockreset_clk),
						  .D_IN(merge_merge_dataport_1$D_IN),
						  .ENQ(merge_merge_dataport_1$ENQ),
						  .DEQ(merge_merge_dataport_1$DEQ),
						  .CLR(merge_merge_dataport_1$CLR),
						  .D_OUT(merge_merge_dataport_1$D_OUT),
						  .FULL_N(merge_merge_dataport_1$FULL_N),
						  .EMPTY_N(merge_merge_dataport_1$EMPTY_N));

  // submodule merge_merge_dataport_2
  FIFOL1 #(.width(32'd35)) merge_merge_dataport_2(.RST_N(csi_clockreset_reset_n),
						  .CLK(csi_clockreset_clk),
						  .D_IN(merge_merge_dataport_2$D_IN),
						  .ENQ(merge_merge_dataport_2$ENQ),
						  .DEQ(merge_merge_dataport_2$DEQ),
						  .CLR(merge_merge_dataport_2$CLR),
						  .D_OUT(merge_merge_dataport_2$D_OUT),
						  .FULL_N(merge_merge_dataport_2$FULL_N),
						  .EMPTY_N(merge_merge_dataport_2$EMPTY_N));

  // submodule merge_responses_vector
  FIFO1 #(.width(32'd33),
	  .guarded(32'd1)) merge_responses_vector(.RST_N(csi_clockreset_reset_n),
						  .CLK(csi_clockreset_clk),
						  .D_IN(merge_responses_vector$D_IN),
						  .ENQ(merge_responses_vector$ENQ),
						  .DEQ(merge_responses_vector$DEQ),
						  .CLR(merge_responses_vector$CLR),
						  .D_OUT(merge_responses_vector$D_OUT),
						  .FULL_N(merge_responses_vector$FULL_N),
						  .EMPTY_N(merge_responses_vector$EMPTY_N));

  // submodule merge_responses_vector_1
  FIFO1 #(.width(32'd33),
	  .guarded(32'd1)) merge_responses_vector_1(.RST_N(csi_clockreset_reset_n),
						    .CLK(csi_clockreset_clk),
						    .D_IN(merge_responses_vector_1$D_IN),
						    .ENQ(merge_responses_vector_1$ENQ),
						    .DEQ(merge_responses_vector_1$DEQ),
						    .CLR(merge_responses_vector_1$CLR),
						    .D_OUT(),
						    .FULL_N(merge_responses_vector_1$FULL_N),
						    .EMPTY_N(merge_responses_vector_1$EMPTY_N));

  // submodule merge_responses_vector_2
  FIFO1 #(.width(32'd33),
	  .guarded(32'd1)) merge_responses_vector_2(.RST_N(csi_clockreset_reset_n),
						    .CLK(csi_clockreset_clk),
						    .D_IN(merge_responses_vector_2$D_IN),
						    .ENQ(merge_responses_vector_2$ENQ),
						    .DEQ(merge_responses_vector_2$DEQ),
						    .CLR(merge_responses_vector_2$CLR),
						    .D_OUT(merge_responses_vector_2$D_OUT),
						    .FULL_N(merge_responses_vector_2$FULL_N),
						    .EMPTY_N(merge_responses_vector_2$EMPTY_N));

  // submodule merge_tags
  SizedFIFO #(.p1width(32'd2),
	      .p2depth(32'd4),
	      .p3cntr_width(32'd2),
	      .guarded(32'd1)) merge_tags(.RST_N(csi_clockreset_reset_n),
					  .CLK(csi_clockreset_clk),
					  .D_IN(merge_tags$D_IN),
					  .ENQ(merge_tags$ENQ),
					  .DEQ(merge_tags$DEQ),
					  .CLR(merge_tags$CLR),
					  .D_OUT(merge_tags$D_OUT),
					  .FULL_N(merge_tags$FULL_N),
					  .EMPTY_N(merge_tags$EMPTY_N));

  // rule RL_mkConnectionGetPut
  assign CAN_FIRE_RL_mkConnectionGetPut =
	     aso_buf$EMPTY_N && aso_stream_out_ready ;
  assign WILL_FIRE_RL_mkConnectionGetPut = CAN_FIRE_RL_mkConnectionGetPut ;

  // rule RL_merge_merge_send_requests
  assign CAN_FIRE_RL_merge_merge_send_requests =
	     merge_merge_dataport$EMPTY_N ;
  assign WILL_FIRE_RL_merge_merge_send_requests =
	     merge_merge_dataport$EMPTY_N ;

  // rule RL_merge_merge_send_requests_1
  assign CAN_FIRE_RL_merge_merge_send_requests_1 =
	     merge_merge_dataport_1$EMPTY_N ;
  assign WILL_FIRE_RL_merge_merge_send_requests_1 =
	     merge_merge_dataport_1$EMPTY_N ;

  // rule RL_merge_merge_send_requests_2
  assign CAN_FIRE_RL_merge_merge_send_requests_2 =
	     merge_merge_dataport_2$EMPTY_N ;
  assign WILL_FIRE_RL_merge_merge_send_requests_2 =
	     merge_merge_dataport_2$EMPTY_N ;

  // rule RL_merge_merge_arbiter_every
  assign CAN_FIRE_RL_merge_merge_arbiter_every = 1'd1 ;
  assign WILL_FIRE_RL_merge_merge_arbiter_every = 1'd1 ;

  // rule RL_merge_merge_grant_one
  assign CAN_FIRE_RL_merge_merge_grant_one =
	     merge_merge_dataport$EMPTY_N && x_grant_id__h3947 == 2'd0 ;
  assign WILL_FIRE_RL_merge_merge_grant_one =
	     CAN_FIRE_RL_merge_merge_grant_one ;

  // rule RL_merge_merge_grant_one_1
  assign CAN_FIRE_RL_merge_merge_grant_one_1 =
	     merge_merge_dataport_1$EMPTY_N && x_grant_id__h3947 == 2'd1 ;
  assign WILL_FIRE_RL_merge_merge_grant_one_1 =
	     CAN_FIRE_RL_merge_merge_grant_one_1 ;

  // rule RL_merge_merge_grant_one_2
  assign CAN_FIRE_RL_merge_merge_grant_one_2 =
	     merge_merge_dataport_2$EMPTY_N && x_grant_id__h3947 == 2'd2 ;
  assign WILL_FIRE_RL_merge_merge_grant_one_2 =
	     CAN_FIRE_RL_merge_merge_grant_one_2 ;

  // rule RL_ClientServerRequest
  assign CAN_FIRE_RL_ClientServerRequest =
	     NOT_avm_adapter_full_master_avalonwait_wget__4_ETC___d132 &&
	     merge_merge_sink_rw$whas &&
	     merge_tags$FULL_N &&
	     avm_adapter_full_master_pending_acks$FULL_N ;
  assign WILL_FIRE_RL_ClientServerRequest = CAN_FIRE_RL_ClientServerRequest ;

  // rule RL_stream_to_jtag
  assign CAN_FIRE_RL_stream_to_jtag =
	     asi_adapter_f$EMPTY_N && merge_merge_dataport_1$FULL_N &&
	     write_space != 16'd0 ;
  assign WILL_FIRE_RL_stream_to_jtag = CAN_FIRE_RL_stream_to_jtag ;

  // rule RL_ClientServerResponse
  assign CAN_FIRE_RL_ClientServerResponse =
	     avm_adapter_full_master_datareturnbuf$EMPTY_N &&
	     merge_tags$EMPTY_N &&
	     CASE_merge_tagsD_OUT_NOT_merge_tagsD_OUT_EQ__ETC__q1 ;
  assign WILL_FIRE_RL_ClientServerResponse =
	     CAN_FIRE_RL_ClientServerResponse ;

  // rule RL_ask_space_available
  assign CAN_FIRE_RL_ask_space_available =
	     merge_merge_dataport$FULL_N && write_space == 16'd0 ;
  assign WILL_FIRE_RL_ask_space_available = CAN_FIRE_RL_ask_space_available ;

  // rule RL_receive_space_available
  assign CAN_FIRE_RL_receive_space_available =
	     merge_responses_vector$EMPTY_N ;
  assign WILL_FIRE_RL_receive_space_available =
	     merge_responses_vector$EMPTY_N ;

  // rule RL_do_not_need_streat_to_jtag_response
  assign CAN_FIRE_RL_do_not_need_streat_to_jtag_response =
	     merge_responses_vector_1$EMPTY_N ;
  assign WILL_FIRE_RL_do_not_need_streat_to_jtag_response =
	     merge_responses_vector_1$EMPTY_N ;

  // rule RL_request_any_data
  assign CAN_FIRE_RL_request_any_data =
	     merge_merge_dataport_2$FULL_N && !aso_buf$EMPTY_N ;
  assign WILL_FIRE_RL_request_any_data = CAN_FIRE_RL_request_any_data ;

  // rule RL_receive_read_data
  assign CAN_FIRE_RL_receive_read_data =
	     merge_responses_vector_2$EMPTY_N &&
	     (!IF_merge_responses_vector_2_first__00_BIT_32_0_ETC___d282[15] ||
	      aso_buf$FULL_N) ;
  assign WILL_FIRE_RL_receive_read_data = CAN_FIRE_RL_receive_read_data ;

  // rule RL_asi_adapter_push_data_into_fifo
  assign CAN_FIRE_RL_asi_adapter_push_data_into_fifo =
	     asi_adapter_f$FULL_N && asi_stream_in_valid &&
	     asi_adapter_d_dw$wget[8] ;
  assign WILL_FIRE_RL_asi_adapter_push_data_into_fifo =
	     CAN_FIRE_RL_asi_adapter_push_data_into_fifo ;

  // rule RL_avm_adapter_full_master_buffer_data_read
  assign CAN_FIRE_RL_avm_adapter_full_master_buffer_data_read =
	     avm_adapter_full_master_pending_acks$EMPTY_N &&
	     !avm_adapter_full_master_write_r &&
	     avm_adapter_full_master_read_r &&
	     !avm_m0_waitrequest &&
	     avm_adapter_full_master_pending_acks$D_OUT == 2'd0 ;
  assign WILL_FIRE_RL_avm_adapter_full_master_buffer_data_read =
	     CAN_FIRE_RL_avm_adapter_full_master_buffer_data_read ;

  // rule RL_avm_adapter_full_master_signal_data_write
  assign CAN_FIRE_RL_avm_adapter_full_master_signal_data_write =
	     avm_adapter_full_master_pending_acks$EMPTY_N &&
	     avm_adapter_full_master_write_r &&
	     !avm_adapter_full_master_read_r &&
	     !avm_m0_waitrequest &&
	     avm_adapter_full_master_pending_acks$D_OUT == 2'd1 ;
  assign WILL_FIRE_RL_avm_adapter_full_master_signal_data_write =
	     CAN_FIRE_RL_avm_adapter_full_master_signal_data_write ;

  // rule RL_avm_adapter_full_master_signal_mem_null
  assign CAN_FIRE_RL_avm_adapter_full_master_signal_mem_null =
	     avm_adapter_full_master_pending_acks$EMPTY_N &&
	     avm_adapter_full_master_pending_acks$D_OUT == 2'd2 ;
  assign WILL_FIRE_RL_avm_adapter_full_master_signal_mem_null =
	     CAN_FIRE_RL_avm_adapter_full_master_signal_mem_null ;

  // rule RL_avm_adapter_full_master_do_read_reg
  assign CAN_FIRE_RL_avm_adapter_full_master_do_read_reg = 1'd1 ;
  assign WILL_FIRE_RL_avm_adapter_full_master_do_read_reg = 1'd1 ;

  // rule RL_avm_adapter_full_master_do_write_reg
  assign CAN_FIRE_RL_avm_adapter_full_master_do_write_reg = 1'd1 ;
  assign WILL_FIRE_RL_avm_adapter_full_master_do_write_reg = 1'd1 ;

  // rule RL_avm_adapter_full_master_datareturnbuf__updateLevelCounter
  assign CAN_FIRE_RL_avm_adapter_full_master_datareturnbuf__updateLevelCounter =
	     avm_adapter_full_master_datareturnbuf_r_enq$whas !=
	     CAN_FIRE_RL_ClientServerResponse ;
  assign WILL_FIRE_RL_avm_adapter_full_master_datareturnbuf__updateLevelCounter =
	     CAN_FIRE_RL_avm_adapter_full_master_datareturnbuf__updateLevelCounter ;

  // inputs to muxes for submodule ports
  assign MUX_avm_adapter_full_master_datareturnbuf$enq_1__VAL_1 =
	     { 1'd1, avm_m0_readdata } ;
  assign MUX_merge_merge_sink_rw$wset_1__VAL_1 =
	     { merge_merge_dataport$D_OUT, 2'd0 } ;
  assign MUX_merge_merge_sink_rw$wset_1__VAL_2 =
	     { merge_merge_dataport_1$D_OUT, 2'd1 } ;
  assign MUX_merge_merge_sink_rw$wset_1__VAL_3 =
	     { merge_merge_dataport_2$D_OUT, 2'd2 } ;

  // inlined wires
  assign asi_adapter_d_dw$wget = { 1'd1, asi_stream_in_data } ;
  assign aso_adapter_data_dw$wget = { 1'd1, aso_buf$D_OUT } ;
  always@(WILL_FIRE_RL_merge_merge_grant_one or
	  MUX_merge_merge_sink_rw$wset_1__VAL_1 or
	  WILL_FIRE_RL_merge_merge_grant_one_1 or
	  MUX_merge_merge_sink_rw$wset_1__VAL_2 or
	  WILL_FIRE_RL_merge_merge_grant_one_2 or
	  MUX_merge_merge_sink_rw$wset_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_merge_merge_grant_one:
	  merge_merge_sink_rw$wget = MUX_merge_merge_sink_rw$wset_1__VAL_1;
      WILL_FIRE_RL_merge_merge_grant_one_1:
	  merge_merge_sink_rw$wget = MUX_merge_merge_sink_rw$wset_1__VAL_2;
      WILL_FIRE_RL_merge_merge_grant_one_2:
	  merge_merge_sink_rw$wget = MUX_merge_merge_sink_rw$wset_1__VAL_3;
      default: merge_merge_sink_rw$wget =
		   37'h0AAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign merge_merge_sink_rw$whas =
	     WILL_FIRE_RL_merge_merge_grant_one ||
	     WILL_FIRE_RL_merge_merge_grant_one_1 ||
	     WILL_FIRE_RL_merge_merge_grant_one_2 ;
  assign avm_adapter_full_master_signal_read$whas =
	     WILL_FIRE_RL_ClientServerRequest &&
	     merge_merge_sink_rw$wget[36:35] == 2'd0 ;
  assign avm_adapter_full_master_signal_write$whas =
	     WILL_FIRE_RL_ClientServerRequest &&
	     merge_merge_sink_rw$wget[36:35] == 2'd1 ;
  assign avm_adapter_full_master_datareturnbuf_r_enq$whas =
	     WILL_FIRE_RL_avm_adapter_full_master_signal_mem_null ||
	     WILL_FIRE_RL_avm_adapter_full_master_signal_data_write ||
	     WILL_FIRE_RL_avm_adapter_full_master_buffer_data_read ;
  assign merge_merge_arbiter_grant_vector$wget =
	     { IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d240 ||
	       IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d229,
	       IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d231 ||
	       IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d88 &&
	       merge_merge_dataport_1$EMPTY_N,
	       IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d230 ||
	       merge_merge_arbiter_priority_vector[0] &&
	       merge_merge_dataport$EMPTY_N } ;

  // register avm_adapter_full_master_address_r
  assign avm_adapter_full_master_address_r$D_IN =
	     merge_merge_sink_rw$wget[34] ;
  assign avm_adapter_full_master_address_r$EN =
	     CAN_FIRE_RL_ClientServerRequest ;

  // register avm_adapter_full_master_byteenable_r
  assign avm_adapter_full_master_byteenable_r$D_IN = 4'b1111 ;
  assign avm_adapter_full_master_byteenable_r$EN =
	     CAN_FIRE_RL_ClientServerRequest ;

  // register avm_adapter_full_master_datareturnbuf_countReg
  assign avm_adapter_full_master_datareturnbuf_countReg$D_IN =
	     avm_adapter_full_master_datareturnbuf_r_enq$whas ?
	       avm_adapter_full_master_datareturnbuf_countReg + 3'd1 :
	       avm_adapter_full_master_datareturnbuf_countReg - 3'd1 ;
  assign avm_adapter_full_master_datareturnbuf_countReg$EN =
	     CAN_FIRE_RL_avm_adapter_full_master_datareturnbuf__updateLevelCounter ;

  // register avm_adapter_full_master_read_r
  assign avm_adapter_full_master_read_r$D_IN =
	     avm_adapter_full_master_signal_read$whas ;
  assign avm_adapter_full_master_read_r$EN =
	     avm_adapter_full_master_signal_read$whas || !avm_m0_waitrequest ;

  // register avm_adapter_full_master_write_r
  assign avm_adapter_full_master_write_r$D_IN =
	     avm_adapter_full_master_signal_write$whas ;
  assign avm_adapter_full_master_write_r$EN =
	     avm_adapter_full_master_signal_write$whas ||
	     !avm_m0_waitrequest ;

  // register avm_adapter_full_master_writedata_r
  assign avm_adapter_full_master_writedata_r$D_IN =
	     merge_merge_sink_rw$wget[33:2] ;
  assign avm_adapter_full_master_writedata_r$EN =
	     CAN_FIRE_RL_ClientServerRequest ;

  // register merge_merge_arbiter_lock_arbiter
  assign merge_merge_arbiter_lock_arbiter$D_IN = 1'd0 ;
  assign merge_merge_arbiter_lock_arbiter$EN =
	     CAN_FIRE_RL_ClientServerRequest ;

  // register merge_merge_arbiter_priority_vector
  assign merge_merge_arbiter_priority_vector$D_IN =
	     { merge_merge_arbiter_grant_vector$wget[1:0],
	       merge_merge_arbiter_grant_vector$wget[2] } ;
  assign merge_merge_arbiter_priority_vector$EN =
	     WILL_FIRE_RL_ClientServerRequest &&
	     merge_merge_arbiter_grant_vector$wget != 3'd0 ;

  // register write_space
  assign write_space$D_IN =
	     IF_merge_responses_vectorD_OUT_BIT_32_THEN_me_ETC__q2[31:16] ;
  assign write_space$EN = merge_responses_vector$EMPTY_N ;

  // submodule asi_adapter_f
  assign asi_adapter_f$D_IN = asi_adapter_d_dw$wget[7:0] ;
  assign asi_adapter_f$ENQ = CAN_FIRE_RL_asi_adapter_push_data_into_fifo ;
  assign asi_adapter_f$DEQ = CAN_FIRE_RL_stream_to_jtag ;
  assign asi_adapter_f$CLR = 1'b0 ;

  // submodule aso_buf
  assign aso_buf$D_IN =
	     IF_merge_responses_vector_2_first__00_BIT_32_0_ETC___d282[7:0] ;
  assign aso_buf$ENQ =
	     WILL_FIRE_RL_receive_read_data &&
	     IF_merge_responses_vector_2_first__00_BIT_32_0_ETC___d282[15] ;
  assign aso_buf$DEQ = CAN_FIRE_RL_mkConnectionGetPut ;
  assign aso_buf$CLR = 1'b0 ;

  // submodule avm_adapter_full_master_datareturnbuf
  assign avm_adapter_full_master_datareturnbuf$D_IN =
	     WILL_FIRE_RL_avm_adapter_full_master_buffer_data_read ?
	       MUX_avm_adapter_full_master_datareturnbuf$enq_1__VAL_1 :
	       33'h0AAAAAAAA ;
  assign avm_adapter_full_master_datareturnbuf$ENQ =
	     WILL_FIRE_RL_avm_adapter_full_master_buffer_data_read ||
	     WILL_FIRE_RL_avm_adapter_full_master_signal_mem_null ||
	     WILL_FIRE_RL_avm_adapter_full_master_signal_data_write ;
  assign avm_adapter_full_master_datareturnbuf$DEQ =
	     CAN_FIRE_RL_ClientServerResponse ;
  assign avm_adapter_full_master_datareturnbuf$CLR = 1'b0 ;

  // submodule avm_adapter_full_master_pending_acks
  assign avm_adapter_full_master_pending_acks$D_IN =
	     merge_merge_sink_rw$wget[36:35] ;
  assign avm_adapter_full_master_pending_acks$ENQ =
	     CAN_FIRE_RL_ClientServerRequest ;
  assign avm_adapter_full_master_pending_acks$DEQ =
	     avm_adapter_full_master_datareturnbuf_r_enq$whas ;
  assign avm_adapter_full_master_pending_acks$CLR = 1'b0 ;

  // submodule merge_merge_dataport
  assign merge_merge_dataport$D_IN = 35'h100000000 ;
  assign merge_merge_dataport$ENQ = CAN_FIRE_RL_ask_space_available ;
  assign merge_merge_dataport$DEQ =
	     WILL_FIRE_RL_ClientServerRequest &&
	     merge_merge_sink_rw$wget[1:0] == 2'd0 ;
  assign merge_merge_dataport$CLR = 1'b0 ;

  // submodule merge_merge_dataport_1
  assign merge_merge_dataport_1$D_IN = { 27'd33554432, asi_adapter_f$D_OUT } ;
  assign merge_merge_dataport_1$ENQ = CAN_FIRE_RL_stream_to_jtag ;
  assign merge_merge_dataport_1$DEQ =
	     WILL_FIRE_RL_ClientServerRequest &&
	     merge_merge_sink_rw$wget[1:0] == 2'd1 ;
  assign merge_merge_dataport_1$CLR = 1'b0 ;

  // submodule merge_merge_dataport_2
  assign merge_merge_dataport_2$D_IN = 35'd0 ;
  assign merge_merge_dataport_2$ENQ = CAN_FIRE_RL_request_any_data ;
  assign merge_merge_dataport_2$DEQ =
	     WILL_FIRE_RL_ClientServerRequest &&
	     merge_merge_sink_rw$wget[1:0] == 2'd2 ;
  assign merge_merge_dataport_2$CLR = 1'b0 ;

  // submodule merge_responses_vector
  assign merge_responses_vector$D_IN =
	     avm_adapter_full_master_datareturnbuf$D_OUT ;
  assign merge_responses_vector$ENQ =
	     WILL_FIRE_RL_ClientServerResponse && merge_tags$D_OUT == 2'd0 ;
  assign merge_responses_vector$DEQ = merge_responses_vector$EMPTY_N ;
  assign merge_responses_vector$CLR = 1'b0 ;

  // submodule merge_responses_vector_1
  assign merge_responses_vector_1$D_IN =
	     avm_adapter_full_master_datareturnbuf$D_OUT ;
  assign merge_responses_vector_1$ENQ =
	     WILL_FIRE_RL_ClientServerResponse && merge_tags$D_OUT == 2'd1 ;
  assign merge_responses_vector_1$DEQ = merge_responses_vector_1$EMPTY_N ;
  assign merge_responses_vector_1$CLR = 1'b0 ;

  // submodule merge_responses_vector_2
  assign merge_responses_vector_2$D_IN =
	     avm_adapter_full_master_datareturnbuf$D_OUT ;
  assign merge_responses_vector_2$ENQ =
	     WILL_FIRE_RL_ClientServerResponse && merge_tags$D_OUT == 2'd2 ;
  assign merge_responses_vector_2$DEQ = CAN_FIRE_RL_receive_read_data ;
  assign merge_responses_vector_2$CLR = 1'b0 ;

  // submodule merge_tags
  assign merge_tags$D_IN = merge_merge_sink_rw$wget[1:0] ;
  assign merge_tags$ENQ = CAN_FIRE_RL_ClientServerRequest ;
  assign merge_tags$DEQ = CAN_FIRE_RL_ClientServerResponse ;
  assign merge_tags$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_IF_merge_merge_arbiter_lock_arbiter_6_THEN__ETC___d246 =
	     IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d229 ?
	       2'd2 :
	       ((IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d88 &&
		 merge_merge_dataport_1$EMPTY_N) ?
		  2'd1 :
		  2'd0) ;
  assign IF_IF_merge_merge_arbiter_lock_arbiter_6_THEN__ETC___d248 =
	     IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d231 ?
	       2'd1 :
	       (IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d230 ?
		  2'd0 :
		  IF_IF_merge_merge_arbiter_lock_arbiter_6_THEN__ETC___d246) ;
  assign IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d229 =
	     (merge_merge_arbiter_lock_arbiter ?
		merge_merge_arbiter_priority_vector[2] :
		merge_merge_arbiter_priority_vector[2] ||
		!merge_merge_dataport_1$EMPTY_N &&
		(merge_merge_arbiter_priority_vector[1] ||
		 !merge_merge_dataport$EMPTY_N &&
		 merge_merge_arbiter_priority_vector[0])) &&
	     merge_merge_dataport_2$EMPTY_N ;
  assign IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d230 =
	     (merge_merge_arbiter_lock_arbiter ?
		merge_merge_arbiter_priority_vector[0] :
		merge_merge_arbiter_priority_vector[0] ||
		NOT_merge_merge_arbiter_priority_vector_7_BIT__ETC___d96) &&
	     merge_merge_dataport$EMPTY_N ;
  assign IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d231 =
	     (merge_merge_arbiter_lock_arbiter ?
		merge_merge_arbiter_priority_vector[1] :
		merge_merge_arbiter_priority_vector[1] ||
		NOT_merge_merge_arbiter_priority_vector_7_BIT__ETC___d84) &&
	     merge_merge_dataport_1$EMPTY_N ;
  assign IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d240 =
	     (merge_merge_arbiter_lock_arbiter ?
		merge_merge_arbiter_priority_vector[2] :
		merge_merge_arbiter_priority_vector[2] ||
		NOT_merge_merge_arbiter_priority_vector_7_BIT__ETC___d63) &&
	     merge_merge_dataport_2$EMPTY_N ;
  assign IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d88 =
	     merge_merge_arbiter_lock_arbiter ?
	       merge_merge_arbiter_priority_vector[1] :
	       merge_merge_arbiter_priority_vector[1] ||
	       !merge_merge_dataport$EMPTY_N &&
	       merge_merge_arbiter_priority_vector[0] ;
  assign IF_merge_responses_vectorD_OUT_BIT_32_THEN_me_ETC__q2 =
	     merge_responses_vector$D_OUT[32] ?
	       merge_responses_vector$D_OUT[31:0] :
	       32'd0 ;
  assign IF_merge_responses_vector_2_first__00_BIT_32_0_ETC___d282 =
	     merge_responses_vector_2$D_OUT[32] ?
	       merge_responses_vector_2$D_OUT[31:0] :
	       32'd0 ;
  assign NOT_avm_adapter_full_master_avalonwait_wget__4_ETC___d132 =
	     (!avm_m0_waitrequest ||
	      !avm_adapter_full_master_read_r &&
	      !avm_adapter_full_master_write_r) &&
	     avm_adapter_full_master_datareturnbuf_countReg < 3'd2 ;
  assign NOT_merge_merge_arbiter_priority_vector_7_BIT__ETC___d63 =
	     (!merge_merge_arbiter_priority_vector[1] &&
	      (merge_merge_dataport$EMPTY_N ||
	       !merge_merge_arbiter_priority_vector[0]) ||
	      !merge_merge_dataport_1$EMPTY_N) &&
	     (merge_merge_arbiter_priority_vector[1] ||
	      !merge_merge_dataport$EMPTY_N &&
	      merge_merge_arbiter_priority_vector[0]) ;
  assign NOT_merge_merge_arbiter_priority_vector_7_BIT__ETC___d84 =
	     (!merge_merge_arbiter_priority_vector[0] &&
	      (merge_merge_dataport_2$EMPTY_N ||
	       !merge_merge_arbiter_priority_vector[2]) ||
	      !merge_merge_dataport$EMPTY_N) &&
	     (merge_merge_arbiter_priority_vector[0] ||
	      !merge_merge_dataport_2$EMPTY_N &&
	      merge_merge_arbiter_priority_vector[2]) ;
  assign NOT_merge_merge_arbiter_priority_vector_7_BIT__ETC___d96 =
	     (!merge_merge_arbiter_priority_vector[2] &&
	      (merge_merge_dataport_1$EMPTY_N ||
	       !merge_merge_arbiter_priority_vector[1]) ||
	      !merge_merge_dataport_2$EMPTY_N) &&
	     (merge_merge_arbiter_priority_vector[2] ||
	      !merge_merge_dataport_1$EMPTY_N &&
	      merge_merge_arbiter_priority_vector[1]) ;
  assign x_grant_id__h3947 =
	     IF_merge_merge_arbiter_lock_arbiter_6_THEN_mer_ETC___d240 ?
	       2'd2 :
	       IF_IF_merge_merge_arbiter_lock_arbiter_6_THEN__ETC___d248 ;
  always@(merge_tags$D_OUT or
	  merge_responses_vector_2$FULL_N or
	  merge_responses_vector$FULL_N or merge_responses_vector_1$FULL_N)
  begin
    case (merge_tags$D_OUT)
      2'd0:
	  CASE_merge_tagsD_OUT_NOT_merge_tagsD_OUT_EQ__ETC__q1 =
	      merge_responses_vector$FULL_N;
      2'd1:
	  CASE_merge_tagsD_OUT_NOT_merge_tagsD_OUT_EQ__ETC__q1 =
	      merge_responses_vector_1$FULL_N;
      default: CASE_merge_tagsD_OUT_NOT_merge_tagsD_OUT_EQ__ETC__q1 =
		   merge_tags$D_OUT != 2'd2 ||
		   merge_responses_vector_2$FULL_N;
    endcase
  end

  // handling of inlined registers

  always@(posedge csi_clockreset_clk)
  begin
    if (!csi_clockreset_reset_n)
      begin
        avm_adapter_full_master_address_r <= `BSV_ASSIGNMENT_DELAY 1'd0;
	avm_adapter_full_master_byteenable_r <= `BSV_ASSIGNMENT_DELAY 4'd0;
	avm_adapter_full_master_datareturnbuf_countReg <= `BSV_ASSIGNMENT_DELAY
	    3'd0;
	avm_adapter_full_master_read_r <= `BSV_ASSIGNMENT_DELAY 1'd0;
	avm_adapter_full_master_write_r <= `BSV_ASSIGNMENT_DELAY 1'd0;
	avm_adapter_full_master_writedata_r <= `BSV_ASSIGNMENT_DELAY 32'd0;
	merge_merge_arbiter_lock_arbiter <= `BSV_ASSIGNMENT_DELAY 1'd0;
	merge_merge_arbiter_priority_vector <= `BSV_ASSIGNMENT_DELAY 3'd1;
	write_space <= `BSV_ASSIGNMENT_DELAY 16'd0;
      end
    else
      begin
        if (avm_adapter_full_master_address_r$EN)
	  avm_adapter_full_master_address_r <= `BSV_ASSIGNMENT_DELAY
	      avm_adapter_full_master_address_r$D_IN;
	if (avm_adapter_full_master_byteenable_r$EN)
	  avm_adapter_full_master_byteenable_r <= `BSV_ASSIGNMENT_DELAY
	      avm_adapter_full_master_byteenable_r$D_IN;
	if (avm_adapter_full_master_datareturnbuf_countReg$EN)
	  avm_adapter_full_master_datareturnbuf_countReg <= `BSV_ASSIGNMENT_DELAY
	      avm_adapter_full_master_datareturnbuf_countReg$D_IN;
	if (avm_adapter_full_master_read_r$EN)
	  avm_adapter_full_master_read_r <= `BSV_ASSIGNMENT_DELAY
	      avm_adapter_full_master_read_r$D_IN;
	if (avm_adapter_full_master_write_r$EN)
	  avm_adapter_full_master_write_r <= `BSV_ASSIGNMENT_DELAY
	      avm_adapter_full_master_write_r$D_IN;
	if (avm_adapter_full_master_writedata_r$EN)
	  avm_adapter_full_master_writedata_r <= `BSV_ASSIGNMENT_DELAY
	      avm_adapter_full_master_writedata_r$D_IN;
	if (merge_merge_arbiter_lock_arbiter$EN)
	  merge_merge_arbiter_lock_arbiter <= `BSV_ASSIGNMENT_DELAY
	      merge_merge_arbiter_lock_arbiter$D_IN;
	if (merge_merge_arbiter_priority_vector$EN)
	  merge_merge_arbiter_priority_vector <= `BSV_ASSIGNMENT_DELAY
	      merge_merge_arbiter_priority_vector$D_IN;
	if (write_space$EN)
	  write_space <= `BSV_ASSIGNMENT_DELAY write_space$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    avm_adapter_full_master_address_r = 1'h0;
    avm_adapter_full_master_byteenable_r = 4'hA;
    avm_adapter_full_master_datareturnbuf_countReg = 3'h2;
    avm_adapter_full_master_read_r = 1'h0;
    avm_adapter_full_master_write_r = 1'h0;
    avm_adapter_full_master_writedata_r = 32'hAAAAAAAA;
    merge_merge_arbiter_lock_arbiter = 1'h0;
    merge_merge_arbiter_priority_vector = 3'h2;
    write_space = 16'hAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkUART2Stream

